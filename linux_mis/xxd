linux 命令 xxd
xd [options] [infile [outfile]]
xxd -r[evert] [options] [infile [outfile]]

xxd 命令用于用二进制或十六进制显示文件的内容，如果没有指定outfile参数，则把结果显示在屏幕上，如果指定了outfile则把结果输出到 outfile中；如果infile参数为 – 或则没有指定infile参数，则默认从标准输入读入。

常用选项：

-b

转到 比特(二进制 数字) 模式, 而不是十六进制模式。在这种模式下, 每个字符被表示成八个 0/1 的数字，而不是一般的十六进制形式。每一行都以一个用十六进制形式表示的行号，后面是ascii (或者 ebcdic) 形式开头。命令行选项 -r, -p 在这个模式下不起作用。

-h

显示帮助信息后退出。

-l N

只输出 N 个字符。

-p

以 postscript的连续十六进制转储输出，这也叫做纯十六进制转储。

-r

逆向操作: 把xxd的十六进制输出内容转换回原文件的二进制内容。

-seek offset

用在 -r 之后: 会在当前档桉的 偏移量上增加 .

-s [+][-]seek

从infile的绝对或者相对偏移量 开始. + 表示相对于标 输入当前的位置 (如果不 标准输入就没有意义了). – 表示从档桉末尾 (如果和 + 连用: 从标准输入当前位置) 向前数一些字符, 从那个地方开始. 如果没有 -s 选项, xxd 从 当前位置开始.

-u

十六进制输出时使用大写字母，默认是小写字母。

使用范例：(摘自xxd man page)

显示 file 除了 前 三行 (十六进制 的 0×30) 的 所有 内容.

$ xxd -s 0×30 file

显示 file 最后 三行 (十六进制 的 0×30) 的 所有 内容.

$ xxd -s -0×30 file

显示 120 个 字符, 每行 20 个 字符, 连续 显示.

$ xxd -l 120 -ps -c 20 xxd.1
2e544820585844203120224d616e75616c207061
676520666f7220787864220a2e5c220a2e5c2220
32317374204d617920313939360a2e5c22204d61
6e207061676520617574686f723a0a2e5c222020
2020546f6e79204e7567656e74203c746f6e7940
7363746e7567656e2e7070702e67752e6564752e

显示 120 个 字符, 每行 12 个 字符.

$ xxd -l 120 -c 12 xxd.1
0000000: 2e54 4820 5858 4420 3120 224d .TH XXD 1 “M
000000c: 616e 7561 6c20 7061 6765 2066 anual page f
0000018: 6f72 2078 7864 220a 2e5c 220a or xxd”..\”.
0000024: 2e5c 2220 3231 7374 204d 6179 .\” 21st May
0000030: 2031 3939 360a 2e5c 2220 4d61 1996..\” Ma
000003c: 6e20 7061 6765 2061 7574 686f n page autho
0000048: 723a 0a2e 5c22 2020 2020 546f r:..\” To
0000054: 6e79 204e 7567 656e 7420 3c74 ny Nugent 
0000060: 6f6e 7940 7363 746e 7567 656e ony@sctnugen
000006c: 2e70 7070 2e67 752e 6564 752e .ppp.gu.edu.

只 显示 xxd.1 中 的 日期.

$ xxd -s 0×28 -l 12 -c 12 xxd.1
0000028: 3231 7374 204d 6179 2031 3939 21st May 199

把 input_file 考到 output_file 并 在 前面 增加 100 个 字节的 0×00.

$ xxd input_file | xxd -r -s 100 > output_file

给 档桉 xxd.1 中的 日期 打 补钉.

$ echo ‘0000029: 3574 68′ | xxd -r – xxd.1
$ xxd -s 0×28 -l 12 -c 12 xxd.1
0000028: 3235 7468 204d 6179 2031 3939 25th May 199

建立 一个 65537 字节的 档桉, 所有 字节 都是 0×00, 除了 最后 一个 字节 是 ‘A’ (十六进制 0×41).

$ echo ‘010000: 41′ | xxd -r > file

打开 autoskip, 显示 上例 中 建立的 档桉.

$ xxd -a -c 12 file
0000000: 0000 0000 0000 0000 0000 0000 …………
*
000fffc: 0000 0000 40 ….A

建立 一个 只 含有 一个 ‘A’ 的 档桉. ‘-r -s’ 后面 的数字 同 档桉 中的 行号 相 抵消; 结果是 开头 的 字节 被跳过了.

$ echo ‘010000: 41′ | xxd -r -s -0×10000 > file

从 串行线 中 读入 一个个的 单独的 字符.

$ xxd -c1 < /dev/term/b &
$ stty < /dev/term/b -echo -opost -isig -icanon min 1
$ echo -n foo > /dev/term/b


当我们需要把二进制转成c语言中使用的16进制字符数组时，命令xxd是很有用的。
